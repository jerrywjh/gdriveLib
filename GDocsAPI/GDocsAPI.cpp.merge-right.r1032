/****************************************************************
This is the main file for Google Docs API functions
Author: Jerry wang 
All right reserved.
*************************************************************/
#include "StdAfx.h"
#include "openssl/crypto.h"
#include "GDocsEntry.h"
#include "GDocsAPI.h"
#include "HelperFunctions.h"
#include "GDocsException.h"

//define Progress Message (User-defined Message);
extern volatile LONG g_bCancelTransfering;   

//login errorCode
const char loginErrCode[][32] =
{
	"BadAuthentication",
	"NotVerified",
	"TermsNotAgreed",
	"Unknown",
	"AccountDeleted",
	"AccountDisabled",
	"ServiceDisabled",
	"ServiceUnavailable"
};
// Error code description
const char loginErrCodeDes[][128]=
{
	"The login request used a username or password that is not recognized. ",
	"The account email address has not been verified.",
	"The user has not agreed to terms.",
	"The error is unknown or unspecified",
	"The user account has been deleted.",
	"The user account has been disabled.",
	"The user's access to the specified service has been disabled.",
	"The service is not available; try again later"
};

/************************************************************************************
OpenSSL不是线程安全的，因此在multi-threaded下面用HTTPS/SSL会出错。下面的方法是为了解决这个问题的。
*******************************************************************************************/
void GDocsAPI::thread_setup(void)
{
	int i;
	
	lock_cs = (HANDLE*)OPENSSL_malloc(CRYPTO_num_locks() * sizeof(HANDLE));
	for (i=0; i<CRYPTO_num_locks(); i++)
	{
		lock_cs[i] = ::CreateMutex(NULL, FALSE, NULL);
	}
	
	CRYPTO_set_locking_callback((void(*)(int, int, const char* , int))GDocsAPI::locking_callback);
	/*id callback already defined in Windows*/
}

void GDocsAPI::thread_cleanup(void)
{
	CRYPTO_set_locking_callback(NULL);
	for (int i=0; i<CRYPTO_num_locks(); i++)
		::CloseHandle(lock_cs[i]);
	
	OPENSSL_free(lock_cs);
}


void GDocsAPI::locking_callback(int mode, int type, const char* /*file*/, int /*line*/)
{
	if (mode & CRYPTO_LOCK)
	{
		::WaitForSingleObject(lock_cs[type], INFINITE);
	}
	else
	{
		::ReleaseMutex(lock_cs[type]);
	}
}


/*call back static function to receive the information of HTTP response.
this fuction can be use for receiving response information for ANY HTTP request!
    ***void *realloc(  void *memblock,   size_t size ); The contents of the block are unchanged up to the shorter of the new and old sizes, although the new block can be in a different location. 
*/
 size_t GDocsAPI::responseWriteCallback(void *ptr, size_t size, size_t nmemb, void *stream)
{
	size_t realSize= size*nmemb;
	struct MemoryStruct * mem = (struct MemoryStruct*)stream;  

	if (mem->memory)
		mem->memory = (char*) realloc(mem->memory, mem->size + realSize+1);  
	else
		mem->memory = (char*) malloc(mem->size+realSize+1);

	if (mem->memory)
	{
		memcpy(&(mem->memory[mem->size]), ptr, realSize);
		mem->size += realSize;
		mem->memory[mem->size]=0;
	}
	return realSize;
}

/**************************************************************************
Write the response to file call back
*************************************************************************/
 size_t GDocsAPI::WriteToFileCallback(void *ptr, size_t size, size_t nmemb, void *stream)
 {
	if (g_bCancelTransfering)
	{
		return CURLE_WRITE_ERROR;
	}
	
	struct TransferInfoStruct*  pDownloadInfo = (struct TransferInfoStruct *)stream;
	
	size_t blockSize = size*nmemb;
	
	HANDLE hFile =  pDownloadInfo->hFile;
	
	DWORD dwWritten =0;
	if (!WriteFile(hFile, ptr, blockSize,  &dwWritten, NULL))
	{
		return CURLE_WRITE_ERROR;
	}
	else if (dwWritten)
	{
		pDownloadInfo->uBytesTransferred += dwWritten;
		INT64 lStartTimeStamp = pDownloadInfo->lStartTimeStamp;
		INT64 lCurrentTimeStamp = HelperFunctions::GetCurrentTimeStamp();
		
		int nSpeed =0;
		if (lCurrentTimeStamp > lStartTimeStamp)
		{
			nSpeed = (INT)((INT64)pDownloadInfo->uBytesTransferred/(lCurrentTimeStamp - lStartTimeStamp));
		}
		
		::SendMessage(pDownloadInfo->hDlg, UWM_PROGRESS, (WPARAM)pDownloadInfo->uBytesTransferred, (LPARAM) nSpeed);
	}
	return blockSize;	
 }
 
 /****************************************************************
 //read call back function, For HTTP PUT command
 ********************************************************************/
 size_t GDocsAPI::readCallback(void *ptr, size_t size, size_t nmemb, void *stream)
 {
 	struct MemoryStruct * mem = (struct MemoryStruct*)stream;
	int iSize = mem->size<size*nmemb? mem->size: size*nmemb;  //min(mem->size, size*nmemb) 
	
	if (iSize >0)
	{
		memcpy(ptr, mem->memory, iSize);
		mem->memory = mem->memory + iSize;
		mem->size -= iSize;
		return iSize;
	}
	else
		return 0;
 }
//
// /*******************************************************************************
// The Callback function for GDocs file upload.
//
// ******************************************************************************/
//size_t GDocsAPI::readFileCallback(void *ptr, size_t size, size_t nmemb, void *stream)
//{
//	if(g_bCancelTransfering)  // 目前仍然只采用一个workerthread来传输文件，有文件在传输的时候，不能增加新的传输(upload/download),y因此可以用一个全局变量来控制
//	{
//		return CURL_READFUNC_ABORT;
//	}
//	
//	struct TransferInfoStruct* pUploadInfo = (struct TransferInfoStruct*)stream;
//
//	size_t  blockSize = size*nmemb;	
//
//	HANDLE hFile = pUploadInfo->hFile;
//	DWORD dwBytesRead = 0;
//	if (!ReadFile(hFile, ptr, blockSize, &dwBytesRead, NULL))
//	{
//		return CURL_READFUNC_ABORT;
//	}
//	else if (dwBytesRead)
//	{
//		//关于速度等的信息，直接在主界面线程中处理，这里只需要传递回去bytesUploaded就可以了。
//		pUploadInfo->uBytesTransferred += dwBytesRead;
//		INT64 lStartTimeStamp = pUploadInfo->lStartTimeStamp;
//		INT64 lCurrentTimeStamp = HelperFunctions::GetCurrentTimeStamp();
//		
//		int nSpeed =0;
//		if (lCurrentTimeStamp > lStartTimeStamp)
//		{
//			nSpeed =(INT)(pUploadInfo->uBytesTransferred/(lCurrentTimeStamp - lStartTimeStamp));
//		}
//			
//		//Send the progress info message to the Message Dialog, send "speed" and "uBytesTransferred" as params 
//		SendMessage(pUploadInfo->hDlg, UWM_PROGRESS, (WPARAM)pUploadInfo->uBytesTransferred, (LPARAM)nSpeed);   //send user-defined message to progress bar dialog
//
//		return dwBytesRead;   //return the acutal number of bytes readed.
//	}
//	return 0;  //end of file, no more data left to deliver
//}



/********************************************************************* 
GDocsAPI constructor:
	Global libcurl initialisaztion, Not thread safe, so must be called in main thread before any subthread started.

Exception: 
	
********************************************************************/
GDocsAPI::GDocsAPI(LPCSTR lpszEmail, LPCSTR lpszPwd)
	:m_pUser(new GDocsUser(lpszEmail, lpszPwd))
{
	CURLcode curlCode= curl_global_init(CURL_GLOBAL_ALL);

	if (curlCode !=0 )
	{
		throw std::runtime_error("HTTP library  initialization failed.");  	
	}
	
	thread_setup();  //this is used for SSL in multi-threaded enviroment.
}

//Destructor
GDocsAPI::~GDocsAPI(void)
{ 
	//clean up the SSL thread setup in thread_setup();
	thread_cleanup();
	//golbal cleanup
	curl_global_cleanup();
}



/*******************************************************
To log in Google Docs using API. :

 Use Google ClientLogin  request to get TWO tokens. (spreadsheet need a different token)
The service name is "writely" or "wise"

There are four possible responses to a login request:
	1.success (an HTTP 200)
	2. failure (an HTTP 403) with an explanatory error code
	3. invalid request, generally resulting from a malformed request
	4. failure with a CAPTCHA challenge

Exception:
	CaptchaRequiredException
	std::runtime_error 

*****************************************************/
void GDocsAPI::ApiLogin(LPCSTR lpszServiceName)
{
	getAuthToken(lpszServiceName);
}

/*****************************************************************
Login with Captcha Chanllege
******************************************************************/
void GDocsAPI::ApiLoginWithCaptcha(LPCSTR lpszServiceName,  LPCSTR lpszCaptchaToken , LPCSTR lpszLoginCaptcha)
{
	getAuthToken(lpszServiceName,lpszCaptchaToken,lpszLoginCaptcha);
}

/**************************************************************
Get  token  for the user 
http://code.google.com/apis/accounts/docs/AuthForInstalledApps.html
Parameter:
	lpszServiceName:	"writely" or "wise" ( GDocs and spreadsheets)
	lpszCaptchaToken:  optional, only used for CAPTCHA challenge. otherwise, be NULL.
	lpszLoginCaptcha:	optional, String entered by the user as an answer to a CAPTCHA challenge. otherwise, be NULL.  
Exception:
****************************************************************/
void GDocsAPI::getAuthToken(LPCSTR lpszServiceName,  LPCSTR lpszCaptchaToken, LPCSTR lpszLoginCaptcha)
{
	LPCSTR lpszEmail = m_pUser->GetEmail();
	LPCSTR lpszPwd = m_pUser->GetPassword();
	if (lpszEmail == NULL || lpszPwd == NULL) 
	{
		throw std::runtime_error("Login Email or Password cannot be empty!");
	}

	CURL* curl = curl_easy_init();  
	if (!curl)
		throw std::runtime_error("Connection initialization failed");  	

	LPSTR lpszEncodedPwd = curl_easy_escape(curl, lpszPwd, 0);

	//set httpheader
	struct curl_slist *headers=NULL;
	headers = curl_slist_append(headers, "GData-Version:3.0");
	CURLcode res= curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
	curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
	curl_easy_setopt(curl, CURLOPT_URL, "https://www.google.com/accounts/ClientLogin");

	//construct the BODY dynamically!!
	int iBodySize = strlen("accountType=HOSTED_OR_GOOGLE") 
				+ strlen("&Email=") + strlen(lpszEmail) 
				+ strlen("&Passwd=") + strlen(lpszEncodedPwd)
				+ strlen("&service=") + strlen(lpszServiceName)
				+ strlen("&source=CloudDrive-GDocsDrive-1.0.0") + 10;

	if (lpszCaptchaToken != NULL && lpszLoginCaptcha != NULL)   //for CAPTCHA challenge!
	{
		iBodySize += strlen("&logintoken=") + strlen(lpszCaptchaToken);
		iBodySize += strlen("&logincaptcha=") + strlen(lpszLoginCaptcha);
	}

	CHAR* lpszBody = new CHAR[iBodySize]();
	strcpy_s(lpszBody, iBodySize,  "accountType=HOSTED_OR_GOOGLE");
	strcat_s(lpszBody, iBodySize,  "&Email=");
	strcat_s(lpszBody, iBodySize,  lpszEmail);
	strcat_s(lpszBody, iBodySize,  "&Passwd=");
	strcat_s(lpszBody, iBodySize,  lpszEncodedPwd);
	strcat_s(lpszBody, iBodySize,  "&service="); 
	strcat_s(lpszBody, iBodySize,  lpszServiceName);
	strcat_s(lpszBody, iBodySize,  "&source=CloudDrive-GoogleDrive-1.0.0");

	if (lpszCaptchaToken != NULL && lpszLoginCaptcha != NULL)   //for CAPTCHA challenge!
	{
		strcat_s(lpszBody, iBodySize,  "&logintoken="); 
		strcat_s(lpszBody, iBodySize,  lpszCaptchaToken);
		strcat_s(lpszBody, iBodySize,  "&logincaptcha="); 
		strcat_s(lpszBody, iBodySize,  lpszLoginCaptcha);
	}

	//free the encoded password string
	curl_free(lpszEncodedPwd);

	curl_easy_setopt(curl, CURLOPT_POSTFIELDS, lpszBody);   //NOTE: string not copyed, so delete[] must be postpone!!!
	
	struct MemoryStruct  responseBuffer;
	responseBuffer.memory = NULL;
	responseBuffer.size = 0;

	curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, GDocsAPI::responseWriteCallback);   
	curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void*)&responseBuffer);

	res= curl_easy_perform(curl);
	if (res != CURLE_OK)
	{
		delete [] lpszBody;
		if (responseBuffer.memory)
			free(responseBuffer.memory);

		if (curl)
			curl_easy_cleanup(curl);		

		throw std::runtime_error("Error: Cannot connect to Google Docs.");
	}

	delete [] lpszBody;

	//Google returns either an HTTP 200, if login succeeded,  or an HTTP 403, if login failed.
	LONG statusCode =0;
	curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &statusCode);

	if (statusCode == 200)
	{
		//if responseBuffer.memory == NULL,出错了！
		if (NULL==responseBuffer.memory)
		{
			if (curl) 
				curl_easy_cleanup(curl);		//cleanup curl
			throw std::runtime_error("Login failed for unknown error.");
		} 		
		
		//succeeded,  get the Auth Token and assign it to GDocsUser
		char* authStr = strstr(responseBuffer.memory, "Auth=")+strlen("Auth=");
		char* authStrEnd = strchr(authStr,10);      // "\n" (new line)  =10
			
		if (authStrEnd)
			authStrEnd[0]=0; //结尾符0

		if (strcmp(lpszServiceName, "writely") ==0 )
		{
			m_pUser->SetTokenForDocs(authStr);
		}
		if (strcmp(lpszServiceName, "wise") == 0 )
		{
			m_pUser->SetTokenForSpreadSheets(authStr);
		}
	}
	else		//failed   403 
	{	
		if (NULL==responseBuffer.memory)
		{
			if (curl) 
				curl_easy_cleanup(curl);		//cleanup curl
			throw std::runtime_error("Login failed for unknown error.");
		} 
		
		char* szCaptchaErr = strstr(responseBuffer.memory, "CaptchaRequired");
		if (szCaptchaErr)
		{
			if (curl) 
				curl_easy_cleanup(curl);		//cleanup curl
			throw CaptchaRequiredException(responseBuffer.memory);  //actually, the responseBuffer.memory cannot be freed.
		}
		else
		{
			//throw excepiton with different message based on the response error code
			for (int i = 0; i < sizeof (loginErrCode) / sizeof (loginErrCode[0]); i++)
			{
				if (strstr(responseBuffer.memory, loginErrCode[i]))
				{
					if (curl)
						curl_easy_cleanup(curl);		//cleanup curl
					throw std::runtime_error (loginErrCodeDes[i]);
				} 
			} 
		}
	}	

	//free the memory for responseBuffer.
	if (responseBuffer.memory)
		free(responseBuffer.memory);

	if (curl)
		curl_easy_cleanup(curl);		//cleanup curl
}

/********************************************************************
Logout():   logs a user out by ending the current session.  
*********************************************************************/
void GDocsAPI::Logout()
{
	delete m_pUser;  //delete do not need to check NULL.  
}


/****************************************************
Check if the user has logged in, 
if not, exception throwed.
***************************************************/
void GDocsAPI::assertUserLoggedIn()
{
	if (m_pUser->GetTokenForDocs() == NULL)
	{
		throw std::runtime_error("The user must be logged in.");
	}
}

/**************************************************************************
Send a Http Get Request to get a CaptchaImg, save the image to temperary file "Captcha.jpg". 
Params:
	lpszCaptchaImgUrl: the url of the CAPTCHA Image.
*****************************************************************************/
void GDocsAPI::GetCaptchaImg(LPCSTR lpszCaptchaImgUrl)
{
	if (lpszCaptchaImgUrl == NULL)
	{
		throw std::runtime_error("Captcha Image Url is invalid");
	}

	CURL* curl = curl_easy_init();  
	if (!curl)
		throw std::runtime_error("Connection initialization failed");  	
		
	//set httpheader
	struct curl_slist *headers=NULL;
	headers = curl_slist_append(headers, "GData-Version:3.0");
	CURLcode res= curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
	curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
	curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);  //自动重定向  处理302的响应   //????use https directly???

	curl_easy_setopt(curl, CURLOPT_URL, lpszCaptchaImgUrl);
	curl_easy_setopt(curl, CURLOPT_HTTPGET, 1L);  //change from POST to GET

	struct MemoryStruct  responseBuffer;
	responseBuffer.memory = NULL;
	responseBuffer.size = 0;

	curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, GDocsAPI::responseWriteCallback);    
	curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void*)&responseBuffer);

	res= curl_easy_perform(curl);

	//save the Captcha img to file "Captcha.jpg"
	HANDLE hCaptchaImg = CreateFile(L"Captcha.jpg", GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, NULL, 
			CREATE_ALWAYS , FILE_ATTRIBUTE_TEMPORARY, NULL);
	if (INVALID_HANDLE_VALUE == hCaptchaImg)
	{
		throw std::runtime_error("Captcha img file creation failed!");
	}

	DWORD dwWritten;
	WriteFile(hCaptchaImg, responseBuffer.memory, responseBuffer.size, &dwWritten, NULL); 
	CloseHandle(hCaptchaImg);

	//free the memory for responseBuffer.
	if (responseBuffer.memory)
		free(responseBuffer.memory);
	//cleanup curl
	if (curl)
		curl_easy_cleanup(curl);		
}


/************************************************************************************
If a GDocs API request failed, usually a XML-format error message is returned.
In most cases, we need to  throw an Exception with the error information to notify the user
that this request is failed for what reason.
This method is used to get the error message from the XML file.

param: 
	[in] lpszErrXmlResponse: the Xml-format Error message; 
	[out] lpszErrMsg: the string for the exception we are going to throw. it's size should be 512 or above
	[in] nSize: the size of the lpszErrMsg buffer, usually 512.
A typical Error Response message is like this:
<errors xmlns='http://schemas.google.com/g/2005'>
	<error>
		<domain>GData</domain>
		<code>ResourceNotFoundException</code>
		<internalReason>Invalid document id: folder:0B7CmbVXdOi7mZjhiYjNiNGItN33TY2MS00ZDFlLWEzYWMtOTFhOWU3NDI5MjFm</internalReason>
	</error>
</errors>
**********************************************************************************/
void GDocsAPI::getErrMsgFromResponse(char* lpszErrXmlResponse, char* lpszErrMsg, int nSize)
{	
	TiXmlDocument* pErrDoc = new TiXmlDocument();
	pErrDoc->Parse(lpszErrXmlResponse, 0, TIXML_ENCODING_UTF8);

	TiXmlElement *pRootEle = pErrDoc->FirstChildElement("errors");
	if (pRootEle)
	{
		TiXmlElement *pErrEle = pRootEle->FirstChildElement("error");
		if (pErrEle)
		{
			TiXmlElement* pErrCodeEle = pErrEle->FirstChildElement("code");
			if (pErrCodeEle)
				strcpy_s(lpszErrMsg, nSize, pErrCodeEle->GetText());

			strcat_s(lpszErrMsg, nSize, " : ");

			TiXmlElement* pErrReasonEle = pErrEle->FirstChildElement("internalReason");
			if (pErrReasonEle)
				strcat_s(lpszErrMsg, nSize, pErrReasonEle->GetText()); 
		}
	}
	else
	{
		lpszErrMsg =" Operation failed for unknown reason.";
	}
	delete pErrDoc;
}

/*************************************************************************
Prepare curl handle for the following http request.
Set the libCurl HTTP request 's header, Setup the debug information, Disable libCurl Certificate verifaction

params:
	[in]curl:  the handle of curl
	[in]lpszContentType: the Content Type of the http request. like "application/atom+xml" ,   NULL for default, 
		in most request, just ignore this param and let libcurl choose the right Content-Type.
	[in]lpszIfMatch:   
			NULL : this header is not required, this is the default value
			*: 	ignore match or not
			Entry-Id:  do it only when match

return:  curl_slist *    the linked list of header string, which must be freed after curl_easy_perform();  //for example: curl_slist_free_all(slist);
**************************************************************************/
curl_slist* GDocsAPI::prepareCurl(CURL* curl,  LPCSTR lpszContentType, LPCSTR lpszIfMatch)
{
	//#ifdef _DEBUG
	//	curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L);		
	//#endif

	curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L); //  do not verify certificate

	struct curl_slist * headers= NULL;
	headers = curl_slist_append(headers, "GData-Version: 3.0");

	//add authorization header
	int iAuthLen = strlen("Authorization: GoogleLogin auth=") +strlen(m_pUser->GetTokenForDocs()) +8;
	CHAR* szAuthToken = new CHAR[iAuthLen]();
	strcpy_s(szAuthToken, iAuthLen, "Authorization: GoogleLogin auth=");
	strcat_s(szAuthToken, iAuthLen, m_pUser->GetTokenForDocs());
	
	headers = curl_slist_append(headers, szAuthToken);
	delete [] szAuthToken;
	
	if (lpszContentType)
	{
		char szContentType[256] ={0};
		strcpy_s(szContentType, "Content-Type:");
		strcat_s(szContentType, lpszContentType);
		headers = curl_slist_append(headers, szContentType);
	}
	
	if (lpszIfMatch)
	{
		char szIfMatch[256]={0};
		strcpy_s(szIfMatch, "If-Match: ");
		strcat_s(szIfMatch, lpszIfMatch);
		headers = curl_slist_append(headers, szIfMatch);
	}
	curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);

	return headers;
}

/***************************************************************************************
Update the meta data of the specific entry,
like: rename the entry, starred/unstarred , view/unview the entry,
params:
	[in] lpszEditLink:  The edit link of the entry, like:href="https://docs.google.com/feeds/default/private/full/document%3A19QlFP5je6Suh7OwnuoyC2Kru5id6UIGMBeaFwbdYQo0"
	[in] lpszMetadata:  like 
		"<title>abc.jpb</title>",   
		"<category scheme="http://schemas.google.com/g/2005/labels" term="http://schemas.google.com/g/2005/labels#viewed" label="viewed"/>"
		<category scheme="http://schemas.google.com/g/2005/labels" term="http://schemas.google.com/g/2005/labels#starred" label="starred"/>
 

***************************************************************************************/
void  GDocsAPI::updateMetadata(LPCSTR lpszEditLink, LPCSTR lpszMetadata)
{
	assertUserLoggedIn(); 

	if (!lpszEditLink || strlen(lpszEditLink)==0)
		throw std::runtime_error("Invalid Entry .");

	CURL* curl = curl_easy_init();
	curl_slist * headerList = prepareCurl(curl, "application/atom+xml", "*");

	curl_easy_setopt(curl,CURLOPT_UPLOAD, 1L);   //use PUT method

	//construct URL
	//int nDim = strlen(lpszEntryId) + 256;
	//char* lpszUrl = new char[nDim]();
	//strcpy_s(lpszUrl,nDim, "https://docs.google.com/feeds/default/private/full/");
	//strcat_s(lpszUrl, nDim, lpszType);
	//strcat_s(lpszUrl, nDim, "%3A");
	//strcat_s(lpszUrl, nDim, lpszEntryId);
	curl_easy_setopt(curl, CURLOPT_URL, lpszEditLink);
	//delete [] lpszUrl;

	//xml body, set read functon
	int nDim = strlen(lpszMetadata) +384;
	char* lpszBody =  new char[nDim]();
	strcpy_s(lpszBody, nDim, "<?xml version='1.0' encoding='UTF-8'?>");
	strcat_s(lpszBody,  nDim, "<entry xmlns=\"http://www.w3.org/2005/Atom\"  xmlns:docs=\"http://schemas.google.com/docs/2007\"  xmlns:gd=\"http://schemas.google.com/g/2005\">");
	strcat_s(lpszBody,  nDim, lpszMetadata);
	strcat_s(lpszBody,  nDim, "</entry>");

	struct MemoryStruct readBuffer;
	readBuffer.memory = lpszBody;
	readBuffer.size = strlen(lpszBody);

	curl_easy_setopt(curl, CURLOPT_READFUNCTION, readCallback);
	curl_easy_setopt(curl, CURLOPT_READDATA, (void*)&readBuffer);

	//set the response write function
	struct MemoryStruct  responseBuffer;
	responseBuffer.memory = NULL;
	responseBuffer.size = 0;
	curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, GDocsAPI::responseWriteCallback);   
	curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void*)&responseBuffer);

	CURLcode res = curl_easy_perform(curl);
	delete [] lpszBody;

	if (res!= CURLE_OK)
	{
		if (responseBuffer.memory)
			free(responseBuffer.memory);
		if (headerList)
			curl_slist_free_all(headerList);
		if (curl)
			curl_easy_cleanup(curl);

		throw std::runtime_error(" Operation Failed, Probably due to connection problem.");
	}

	LONG statusCode =0;
	curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &statusCode);
	if (statusCode >=400)  //error happens!
	{
		char szErrMsg[512] ={0};
		getErrMsgFromResponse(responseBuffer.memory, szErrMsg, 512);
		
		if (responseBuffer.memory)
			free(responseBuffer.memory);
		if (headerList)
			curl_slist_free_all(headerList);
		if (curl)
			curl_easy_cleanup(curl);

		throw std::runtime_error(szErrMsg);
	}

	if (responseBuffer.memory)
		free(responseBuffer.memory);
	if (headerList)
		curl_slist_free_all(headerList);
	if (curl)
		curl_easy_cleanup(curl);
}

/********************************************
get the current user object
************************************************/
GDocsUser* GDocsAPI::GetUser()
{
	return m_pUser;
}


/*****************************************************************
Get the general information about the current Google user, including email, name, qutoa ...
And update  m_pUser object!
Actually, this function can be viewed as  "UpdateUserInfo"
****************************************************************/
void GDocsAPI::GetUserInfo()
{
	assertUserLoggedIn();

	CURL* curl = curl_easy_init();
	if (!curl)
		throw std::runtime_error("Connection failed");

	//set the header and other options, headerList should be freed after curl_easy_perform()
	curl_slist * headerList = prepareCurl(curl);
	
	curl_easy_setopt(curl, CURLOPT_URL, "https://docs.google.com/feeds/metadata/default");

	//Set write callback function
	struct MemoryStruct  responseBuffer;
	responseBuffer.memory = NULL;
	responseBuffer.size = 0;

	curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, GDocsAPI::responseWriteCallback);    
	curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void*)&responseBuffer);

	CURLcode res= curl_easy_perform(curl);
	if (res != CURLE_OK)
	{
		if (responseBuffer.memory)
			free(responseBuffer.memory);

		if (headerList)
			curl_slist_free_all(headerList);	//free hader slist
		
		if (curl)
			curl_easy_cleanup(curl);		//free curl handle 

		throw std::runtime_error("Get user information failed");	
	}

	LONG statusCode =0;
	curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &statusCode);

	if (statusCode <400)  //succeed
	{
		TiXmlDocument* pXmlDoc = new TiXmlDocument();
		pXmlDoc->Parse(responseBuffer.memory, 0, TIXML_ENCODING_UTF8);  

		//get the general user information from xml response
		TiXmlElement* pEntryElement = pXmlDoc->FirstChildElement("entry");
		if (pEntryElement)
		{
			TiXmlElement* pAuthorElement = pEntryElement->FirstChildElement("author");
			if (pAuthorElement)
			{
				TiXmlElement* pNameElement = pAuthorElement->FirstChildElement("name");
				if (pNameElement)
				{
					m_pUser->SetName( pNameElement->GetText() );
				}
			}

			TiXmlElement* pQuotaBytesTotalElement = pEntryElement->FirstChildElement("gd:quotaBytesTotal");
			if (pQuotaBytesTotalElement)
			{
				m_pUser->SetQuotaBytesTotal( _atoi64(pQuotaBytesTotalElement->GetText()) );
			}

			TiXmlElement* pQuotaBytesUsedElement = pEntryElement->FirstChildElement("gd:quotaBytesUsed");
			if (pQuotaBytesUsedElement)
			{
				m_pUser->SetQuotaBytesUsed( _atoi64(pQuotaBytesUsedElement->GetText()) );
			}

			TiXmlElement* pQuotaBytesUsedInTrashElement = pEntryElement->FirstChildElement("docs:quotaBytesUsedInTrash");
			if (pQuotaBytesUsedInTrashElement)
			{
				m_pUser->SetQuotaBytesUsedInTrash( _atoi64(pQuotaBytesUsedInTrashElement->GetText()) );
			}

			TiXmlElement* pMaxUploadSizeElement = pEntryElement->FirstChildElement("docs:maxUploadSize");  
			for ( pMaxUploadSizeElement; pMaxUploadSizeElement; pMaxUploadSizeElement=pMaxUploadSizeElement->NextSiblingElement("docs:maxUploadSize") )
			{
				if (strcmp(pMaxUploadSizeElement->Attribute("kind"),"document") == 0)
				{
					m_pUser->SetMaxUploadSizeForDocument( _atoi64(pMaxUploadSizeElement->GetText()) );
				}

				if (strcmp(pMaxUploadSizeElement->Attribute("kind"),"spreadsheet") == 0)
				{
					m_pUser->SetMaxUploadSizeForSpreadsheet( _atoi64(pMaxUploadSizeElement->GetText()) );
				}

				if (strcmp(pMaxUploadSizeElement->Attribute("kind"),"presentation") == 0)
				{
					m_pUser->SetMaxUploadSizeForPresentation( _atoi64(pMaxUploadSizeElement->GetText()) );
				}

				if (strcmp(pMaxUploadSizeElement->Attribute("kind"),"drawing") == 0)
				{
					m_pUser->SetMaxUploadSizeForDrawing( _atoi64(pMaxUploadSizeElement->GetText()) );
				}

				if (strcmp(pMaxUploadSizeElement->Attribute("kind"),"pdf") == 0)
				{
					m_pUser->SetMaxUploadSizeForPdf( _atoi64(pMaxUploadSizeElement->GetText()) );
				}

				if (strcmp(pMaxUploadSizeElement->Attribute("kind"),"file") == 0)
				{
					m_pUser->SetMaxUploadSizeForFile( _atoi64(pMaxUploadSizeElement->GetText()) );
				}
			}
		}

		delete pXmlDoc;

		if (responseBuffer.memory)
			free(responseBuffer.memory);

		if (headerList)
			curl_slist_free_all(headerList);	//free hader slist
		
		if (curl)
			curl_easy_cleanup(curl);		//free curl handle 
	}
	else  //error happend， use the default value
	{
		if (responseBuffer.memory)
			free(responseBuffer.memory);

		if (headerList)
			curl_slist_free_all(headerList);	//free hader slist
		
		if (curl)
			curl_easy_cleanup(curl);		//free curl handle 
	}
}


/*************************************************************************************
Get  all entries of different type in a specific folder 
This function  can be used to retrieve different entries. 
parameters:
	[in] lpszUrl:  FOR all enties in ROOT: https://docs.google.com/feeds/default/private/full?showfolders=true
				for next page: https://docs.google.com/feeds/default/private/full?start-key=EAEasdfldsjfkjfdfsldf, 由,<feed> 's next link决定
				for folder: https://docs.google.com/feeds/default/private/full/folder%2Afolder_id/content   (不需要showfolders=true)
				for all spreadsheet: https://docs.google.com/feeds/default/private/full/-/spreadsheet
				for all starred PDF: https://docs.google.com/feeds/default/private/full/-/pdf/starred 
				for filename contain "qian qian": https://docs.google.com/feeds/default/private/full?title=qian+qian"
				.....
				.....
	[out] pXmlDoc:  the tinyXml doc objetct


google docs returns 100 entry list for each request, which means the entries in pXmlDoc is no more than 100.
so if the user want all the whole entrylist, he should check the returned pXmlDoc to see if "start-key" link exist.
usually it should be done in a loop operation.
**************************************************************************************/
void  GDocsAPI::GetEntryList(LPCSTR lpszUrl, TiXmlDocument* pXmlDoc)
{	
	assertUserLoggedIn();  

	CURL* curl = curl_easy_init(); 
	if (!curl)
		throw std::runtime_error("Connection failed");  	

	//set the header and other options, headerList should be freed after curl_easy_perform()
	curl_slist * headerList = prepareCurl(curl);
	
	
	//char* encodedUrl = curl_easy_escape(curl, lpszUrl,  0);
	curl_easy_setopt(curl, CURLOPT_URL, lpszUrl);
	//curl_free(encodedUrl);

	//Set write callback function
	struct MemoryStruct  responseBuffer;
	responseBuffer.memory = NULL;
	responseBuffer.size = 0;

	curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, GDocsAPI::responseWriteCallback);    
	curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void*)&responseBuffer);

	CURLcode res= curl_easy_perform(curl);
	if (res!= CURLE_OK)
	{
		if (responseBuffer.memory)
			free(responseBuffer.memory);

		if (headerList)
			curl_slist_free_all(headerList);	//free hader slist
		
		if (curl)
			curl_easy_cleanup(curl);		//free curl handle 

		throw std::runtime_error("Get entry list failed");
	}

	LONG statusCode =0;
	curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &statusCode);

	if (statusCode <400)  //succeed
	{
		pXmlDoc->Clear();  //?????对么
		pXmlDoc->Parse(responseBuffer.memory, 0, TIXML_ENCODING_UTF8);  

		if (responseBuffer.memory)
			free(responseBuffer.memory);

		if (headerList)
			curl_slist_free_all(headerList);	//free hader slist
		
		if (curl)
			curl_easy_cleanup(curl);		//free curl handle 
	}
	else  //error happend
	{
		char szErrMsg[512]={0};
		getErrMsgFromResponse(responseBuffer.memory, szErrMsg, 512);

		if (responseBuffer.memory)
			free(responseBuffer.memory);

		if (headerList)
			curl_slist_free_all(headerList);	//free hader slist
		
		if (curl)
			curl_easy_cleanup(curl);		//free curl handle 
	
		throw std::runtime_error(szErrMsg);
	}
}

/************************************************************************
this method is used in UploadFile()
Set the resumable chunk upload header, format:
		Content-Length: 10240
		Content-Type: application/pdf
		Content-Range: bytes 0-10240/12345678

*************************************************************************/
curl_slist* GDocsAPI::generateChunkUploadRequestHeader(CURL* curl, LPCSTR pszContentType, INT64 lFileSize, INT64 lBytesUploaded)
{
	char szContentLength[64]={0};
	char szContentRange[128]={0};

	struct curl_slist* headers = NULL;

	//content type
	headers = curl_slist_append(headers, pszContentType);

	//content length
	INT64 lChunkSize =0; 
	if (lFileSize-lBytesUploaded > BUFFERSIZE)
		lChunkSize = BUFFERSIZE;
	else
		lChunkSize = lFileSize - lBytesUploaded;

	sprintf_s(szContentLength, sizeof(szContentLength), "Content-Length: %I64d", lChunkSize);
	headers = curl_slist_append(headers, szContentLength);

	//content-range /
	sprintf_s(szContentRange, sizeof(szContentRange), "Content-Range: bytes %I64d-%I64d/%I64d", lBytesUploaded, lBytesUploaded+lChunkSize-1, lFileSize); 
	headers = curl_slist_append(headers, szContentRange);

	return headers;
}

/************************************************************************
For uploading request, if you receive an HTTP 503 response,  you need to query the current status of the upload by issuing an empty PUT request on the unique upload URI
param:
	curl: [in]the CURL handle 
	lFileSize: [in] the size of the file
	szUploadUri : [in][out] the upload Uri for PUT
	nSize: [in] the size of szUploadUri
return :
    the number of the last uploaded byte

**********************************************************************/
INT64 GDocsAPI::getResumableRange(CURL *curl, INT64 lFileSize, LPSTR szUploadUri, size_t nSize)
{
	//set headers
	struct curl_slist* headers = NULL;
	headers = curl_slist_append(headers, "Content-Length:0");
	char szContentRange[96]={0};
	sprintf_s(szContentRange, sizeof(szContentRange), "Content-Range: bytes */%I64d", lFileSize);
	headers = curl_slist_append(headers, szContentRange); 
	curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);

	//set url
	curl_easy_setopt(curl, CURLOPT_URL, szUploadUri);

	//set the response write function

	//set the response write function
	struct MemoryStruct  responseBuffer;
	responseBuffer.memory = NULL;
	responseBuffer.size = 0;
	curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, GDocsAPI::responseWriteCallback);   
	curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void*)&responseBuffer);

	CURLcode res = curl_easy_perform(curl);
	if (res != CURLE_OK)
	{
		if (responseBuffer.memory)
			free(responseBuffer.memory);

		if (headers)
			curl_slist_free_all(headers);

		return 0; //从头开始 
	}
			
	LONG statusCode =0;
	curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &statusCode);
	if (statusCode == 308 )  // resume incomplete
	{
		//get the new upload url if it is present, and use this new url for the remaining chunks 
		char * pszNewUploadUri = strstr(responseBuffer.memory, "Location:");
		if (pszNewUploadUri)
		{
			memset(szUploadUri, 0, nSize);
			strcpy_s(szUploadUri, nSize, pszNewUploadUri+9);
		}
		//get the number of uploaded bytes
		INT64 lReturn = 0; 
		char * pszRange = strstr(responseBuffer.memory, "Range:");
		if (pszRange)
		{
			char* pszLastNumber = strstr(pszRange,"-");
			if (pszLastNumber)
			{
				char* pszBytesUploaded = pszLastNumber+1;
				lReturn = _atoi64(pszBytesUploaded)+1;  //这个可以自动截断 ！！
			}
		}
		if (responseBuffer.memory)
			free(responseBuffer.memory);

		if (headers)
			curl_slist_free_all(headers);

		return lReturn;
	}
	else
	{
		if (responseBuffer.memory)
			free(responseBuffer.memory);

		if (headers)
			curl_slist_free_all(headers);

		return 0; //从头开始 
	}
}

/************************************************************
there are different size limitations to convert to document, spreadsheet, presentation,drawing files 
if the uploading file cannot be converted to corresponding type, return FALSE, else return TRUE
params:
	pUser: the current login user
	lpszFileName: the name of the uploading file, not the full path
	lFileSize: the size of the uploading file
****************************************************************/
BOOL GDocsAPI::isFileSizeConvertable(GDocsUser* pUser, LPCWSTR lpszFileName, INT64 lFileSize)
{
	if (HelperFunctions::CanBeConvertedToDocument(lpszFileName))
	{
		if (lFileSize>pUser->GetMaxUploadSizeForDocument())
		{
			return FALSE;
		}
	}

	if (HelperFunctions::CanBeConvertedToSpreadsheet(lpszFileName))
	{
		if (lFileSize>pUser->GetMaxUploadSizeForSpreadsheet())
		{
			return  FALSE;
		}
	}

	if (HelperFunctions::CanBeConvertedToPresentation(lpszFileName))
	{
		if (lFileSize>pUser->GetMaxUploadSizeForPresentation())
		{
			return FALSE;
		}
	}
	return TRUE;
}

/***************************************************************************
Generate the upload HTTP Post header for the curl request
params:
	[in] curl:  the curl handle
	[in] lpszFileName: the name of the uploading file , not the path
	[in] Mimetype, like "application/pdf"
	[in] lFileSize: the size of the uploading file

return:  the header linked list, which must be freed after curl_easy_perform() .  like: curl_slist_free_all( headers)
*****************************************************************************/
curl_slist* GDocsAPI::generateUploadRequestHeader(CURL* curl, LPCWSTR lpszFileName, LPCSTR lpszMimeType, INT64 lFileSize)
{
	struct curl_slist * headers= NULL;
	headers = curl_slist_append(headers, "GData-Version:3.0");

	//add authorization header
	int iAuthLen = strlen("Authorization:GoogleLogin auth=") +strlen(m_pUser->GetTokenForDocs()) +8;
	CHAR* szAuthToken = new CHAR[iAuthLen]();
	strcpy_s(szAuthToken, iAuthLen, "Authorization:GoogleLogin auth=");
	strcat_s(szAuthToken, iAuthLen, m_pUser->GetTokenForDocs());
	headers = curl_slist_append(headers, szAuthToken);
	delete [] szAuthToken;

	//add Content-Length header : "Content-Length:0"; use Slug to define the filename(Title)
	headers = curl_slist_append(headers, "Content-Length:0");

	//add Content-Type header
	CHAR szContentType[256]={0};  //like:  "Content-Type:application/pdf
	if (lpszMimeType!= NULL)
	{
		strcpy_s(szContentType, "Content-Type: ");
		strcat_s(szContentType, lpszMimeType);
	}
	headers = curl_slist_append(headers, szContentType);

	//add  slug file name header
	CHAR szSlug[MAX_PATH] ={0};
	//convert to UTF_8 format, and encoded
	CHAR szUTF8FileName[MAX_PATH]={0};
	WideCharToMultiByte(CP_UTF8, 0, lpszFileName, -1, szUTF8FileName, MAX_PATH, NULL, NULL);
	char* szEncodedFileName = curl_easy_escape(curl, szUTF8FileName, strlen(szUTF8FileName));   //need to be freed later
	strcpy_s(szSlug, "Slug: ");
	if (strlen(szEncodedFileName)>250)   //truncate if the filename is too long
	{
		*(szEncodedFileName+250) =0;
	}
	strcat_s(szSlug, szEncodedFileName);
	headers = curl_slist_append(headers, szSlug);
	curl_free(szEncodedFileName); //free the encoded string

	//add X-Upload-Content-Type:
	CHAR szXUploadContentType[256]={0};
	if (lpszMimeType != NULL)
	{
		strcpy_s(szXUploadContentType, "X-Upload-Content-Type:");
		strcat_s(szXUploadContentType, lpszMimeType);
	}
	else
	{
		strcpy_s(szXUploadContentType, "X-Upload-Content-Type: application/octet-stream");
	}
	headers = curl_slist_append(headers, szXUploadContentType);

	//Add X-upload-content-length
	CHAR szXUploadContentLength[64]={0};
	sprintf_s(szXUploadContentLength, sizeof(szXUploadContentLength), "X-Upload-Content-Length: %I64d", lFileSize);
	headers = curl_slist_append(headers, szXUploadContentLength);

	return headers;
}

/*******************************************************************************
Upload file to Google docs, including converted file and unconverted file.
Params:
	[in]lpszFileFullPathName: the name of the file, including the path. for example: L "e:\test\doc\aaa.txt"
	[in]lpszResumableCreateMediaUrl:   <link rel="http://schemas.google.com/g/2005#resumable-create-media" type="application/atom+xml" href="https://docs.google.com/feeds/upload/create-session/default/private/full"/>
	[in]hMsg:  the progressbar  message window
	[in]bConvert: TRUE: convert to Google format, FALSE: not convert, keep the original format. 
	[out] pResponseDoc: the TinyXml Document object for <entry> response.

Exception:
	runtime_error:

	如果  convert 失败 ，要try non-covert的方式 
**********************************************************************************************/
void GDocsAPI::UploadFile( LPCWSTR lpszFileFullPathName, LPCSTR lpszResumableCreateMediaUrl, HWND hMsg, BOOL bConvert, TiXmlDocument* pResponseDoc)
{
	assertUserLoggedIn(); 
	
	//arguments checking
	if (!lpszFileFullPathName || wcslen(lpszFileFullPathName) ==0 ) 
	{
		throw std::runtime_error("the file name is invalid!");
	}
	
	//get the filename from file full path
	WCHAR lpszFileName[MAX_PATH];
	HelperFunctions::GetFileNameFromFilePath(lpszFileFullPathName, lpszFileName, MAX_PATH); 
	
	//check the size of file: different type has different max size for uploading  
	INT64 lFileSize = HelperFunctions::GetFileSize(lpszFileFullPathName);   	

	if (lFileSize > (m_pUser->GetQuotaBytesTotal()-m_pUser->GetQuotaBytesUsed()))  //quota exceeded!
	{
		throw std::runtime_error(" Your Google space quota is not enough.");
	}

	// if bConvert=TRUE,  size limitation is different for different file types. If filesize exceed max limit, upload it in original format(NOT convert)	// if bConvert = FALSE,  usually file size does not exceed 10GB
	if (bConvert)
	{
		if (!isFileSizeConvertable(m_pUser, lpszFileName, lFileSize))
			bConvert = FALSE;
	}
	else
	{
		if (lFileSize > m_pUser->GetMaxUploadSizeForFile())
			throw std::runtime_error(" File is too large to upload."); 
	}

	//open the file for reading
	HANDLE hFile = ::CreateFileW(lpszFileFullPathName, GENERIC_READ,  
									FILE_SHARE_READ, NULL, OPEN_EXISTING, 
									NULL, NULL); 
	if (hFile == INVALID_HANDLE_VALUE)
		throw std::runtime_error("open file failed!");

	//start of http request
	CURL* curl = curl_easy_init();  
	if (!curl)
	{
		CloseHandle(hFile);
		throw std::runtime_error("Connection failed");  	
	}

	BOOL bRetryNonConvertUpload=FALSE;  //缺省的时候,不需要retry ,只有一种情况需要：bConvert=TRUE,而且失败了，这种情况下要采用 bConvert=FALSE的方式retry
	
	CHAR szContentType[256]={0};  //like:  "Content-Type:application/pdf
	LPCSTR szMimeType =  HelperFunctions::GetMimeTypeFromFileName(lpszFileName); 
	strcpy_s(szContentType, "Content-Type: ");
	strcat_s(szContentType, szMimeType);

	curl_slist* headers = generateUploadRequestHeader(curl, lpszFileName, szMimeType, lFileSize);
	curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
	curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L); //  do not verify certificate
	curl_easy_setopt(curl, CURLOPT_POST, 1L);

	do  //这个循环主要是为了 解决 bConvert=true的情况下失败需要retry
	{
		if (bConvert)
		{
			curl_easy_setopt(curl, CURLOPT_URL, lpszResumableCreateMediaUrl);
		}
		else
		{
			int nDim = strlen(lpszResumableCreateMediaUrl)+32;
			char* pszPostUrl = new char[nDim]();
			strcpy_s(pszPostUrl, nDim, lpszResumableCreateMediaUrl);
			strcat_s(pszPostUrl, nDim,"?convert=false");
			curl_easy_setopt(curl,CURLOPT_URL, pszPostUrl);
			
			bRetryNonConvertUpload=FALSE;//这种情况下，不能再循环了
		}

		//set the response write function
		struct MemoryStruct  responseBuffer;
		responseBuffer.memory = NULL;
		responseBuffer.size = 0;
		curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, GDocsAPI::responseWriteCallback);   
		curl_easy_setopt(curl, CURLOPT_HEADERDATA, (void*)&responseBuffer);
		 
		CURLcode res = curl_easy_perform(curl);
		if ( res!= CURLE_OK)
		{
			//free the memory for responseBuffer.
			if (responseBuffer.memory)
				free(responseBuffer.memory);
			//free header  slist
			if (headers)
				curl_slist_free_all(headers); 
			//free curl handle 
			if (curl)
				curl_easy_cleanup(curl);

			CloseHandle(hFile);
			throw std::runtime_error("Failed to upload file, upload request failed.");
		}

		//get response info..	Google returns 200 for sucessful file resumable uploda request. format: "200 OK  LOcation:<upload_uri>"
		LONG statusCode =0;
		curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &statusCode);

		char szUploadUri[2048] = {0};
		if (statusCode == 200 )
		{
			char* pszUri = strstr(responseBuffer.memory, "Location:");
			if (pszUri)
			{
				pszUri +=10;
				char * pszUriEnd = strstr(pszUri, "\r\n");
				if (pszUriEnd)
				{
					pszUriEnd[0] = 0;
				}

				strcpy_s(szUploadUri, sizeof(szUploadUri), pszUri);
			}
			else
			{
				if (responseBuffer.memory)
					free(responseBuffer.memory);

				if (headers)
					curl_slist_free_all(headers); 

				if (curl)
					curl_easy_cleanup(curl);

				throw std::runtime_error("File upload failed: no upload uri is generated.");
			}
			
			if (responseBuffer.memory)
				free(responseBuffer.memory);

			//if (headers)
			//	curl_slist_free_all(headers); 
		}
		else
		{
			char szErrMsg[512]={0};
			getErrMsgFromResponse(responseBuffer.memory, szErrMsg, 512);
			
			if (responseBuffer.memory)
				free(responseBuffer.memory);

			if (headers)
				curl_slist_free_all(headers); 

			if (curl)
				curl_easy_cleanup(curl);

			throw std::runtime_error(szErrMsg);
		}

		
		
		
		//start the content chunks uploading.............................................
	//	if (curl)
//		curl_easy_reset(curl);

		curl_easy_cleanup(curl);
		curl= curl_easy_init();

		INT64 lBytesUploaded =0;
		BOOL bUploadFinished = FALSE;
	
		curl_easy_setopt(curl,CURLOPT_UPLOAD, 1L);   //use PUT method
		curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L); //  do not verify certificate

		//set the read function
	//	struct TransferInfoStruct uploadInfo;
	//	uploadInfo.hFile = hFile;
	//	uploadInfo.hDlg = hMsg;
		//set the response write function
		
		do 
		{
			//set headers
			struct curl_slist* headersForChunk = NULL;
			headersForChunk = generateChunkUploadRequestHeader(curl, szContentType, lFileSize, lBytesUploaded);  //set the header of the HTTP PUT request
			curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headersForChunk);

			//set URL
			curl_easy_setopt(curl, CURLOPT_URL, szUploadUri);

			

			////set the body 
			INT64 lChunkSize =0; 
			if (lFileSize-lBytesUploaded > BUFFERSIZE)
				lChunkSize = BUFFERSIZE;
			else
				lChunkSize = lFileSize - lBytesUploaded;


			//BYTE*  pChunkBuffer = new BYTE[lChunkSize] {0};

			CHAR  chunkBuffer[BUFFERSIZE] ={0};
			
			DWORD dwBytesRead=0;

			if (!::ReadFile(hFile, chunkBuffer, BUFFERSIZE, &dwBytesRead, NULL))
			{
				
				CloseHandle(hFile);
				if (headersForChunk)
					curl_slist_free_all(headersForChunk); 
				//free curl handle 
				if (curl)
					curl_easy_cleanup(curl);
				
				throw std::runtime_error("Cannot read file.");

			}

			struct MemoryStruct  readBuffer;
			readBuffer.memory = chunkBuffer;
			readBuffer.size = lChunkSize; //strlen(chunkBuffer);
			curl_easy_setopt(curl, CURLOPT_READFUNCTION, readCallback);
			curl_easy_setopt(curl, CURLOPT_READDATA, (void*)&readBuffer);

 

			//uploadInfo.uBytesTransferred =lBytesUploaded;
			//uploadInfo.lStartTimeStamp = HelperFunctions::GetCurrentTimeStamp();
			//curl_easy_setopt(curl, CURLOPT_READFUNCTION,  GDocsAPI::readFileCallback);
			//curl_easy_setopt(curl, CURLOPT_READDATA, (void*)&uploadInfo );


			struct MemoryStruct  responseBufferForContent;
			responseBufferForContent.memory = NULL;
			responseBufferForContent.size = 0;

			//set the response write function
			//if (responseBufferForContent.memory)
				//free(responseBufferForContent.memory);
			
			//responseBufferForContent.memory = NULL;
			//responseBufferForContent.size = 0;
			//curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, GDocsAPI::responseWriteCallback);   
			//curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void*)&responseBufferForContent);
			curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, GDocsAPI::responseWriteCallback);   
			curl_easy_setopt(curl, CURLOPT_HEADERDATA, (void*)&responseBufferForContent);

			CURLcode res = curl_easy_perform(curl);

			if (res != CURLE_OK)
			{
				//free the memory for responseBuffer.
				if (responseBufferForContent.memory)
					free(responseBufferForContent.memory);
				//free header  slist
				if (headersForChunk)
					curl_slist_free_all(headersForChunk); 
				//free curl handle 
				if (curl)
					curl_easy_cleanup(curl);

				CloseHandle(hFile);

				throw std::runtime_error("Failed to upload file:Connection problem.");
			}

			//get response info..	Google returns 201 for sucessful file creation.
			LONG statusCode =0;
			curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &statusCode);

			if (statusCode == 308 )  // resume incomplete
			{
				//get the new upload url if it is present, and use this new url for the remaining chunks 
				char * pszNewUploadUri = strstr(responseBufferForContent.memory, "Location:");
				if (pszNewUploadUri)
				{
					memset(szUploadUri, 0, _countof(szUploadUri));
					strcpy_s(szUploadUri, sizeof(szUploadUri), pszNewUploadUri+9);
				}

				//get the number of uploaded bytes
				char * pszRange = strstr(responseBufferForContent.memory, "Range:");
				if (pszRange)
				{
					char* pszLastNumber = strstr(pszRange,"-");
					if (pszLastNumber)
					{
						char* pszBytesUploaded = pszLastNumber+1;
						//size_t nEndPos = strcspn(pszBytesUploaded+1, " \r\n");
						//if (nEndPos<_countof(pszBytesUploaded))  //????_countof 对 指针有效么??/
						//{
						//	pszBytesUploaded[nEndPos] = 0;
						//}
						
						lBytesUploaded = _atoi64(pszBytesUploaded)+1;  //这个可以自动截断 ！！
					}
				}
				//set the new header
			//	setResumableChunkUploadHeader(headersForChunk, szContentType, lFileSize, lBytesUploaded);

				//free the memory for responseBuffer.
				if (responseBufferForContent.memory)
					free(responseBufferForContent.memory);
			}
			else if (statusCode == 201)   //sucessfully complete
			{

				pResponseDoc->Clear();
				pResponseDoc->Parse(responseBufferForContent.memory,0, TIXML_ENCODING_UTF8);


				//free the memory for responseBuffer.
				if (responseBufferForContent.memory)
					free(responseBufferForContent.memory);
				//free header  slist
				if (headersForChunk)
					curl_slist_free_all(headersForChunk); 
				//free curl handle 
				if (curl)
					curl_easy_cleanup(curl);

				CloseHandle(hFile);
			
				bUploadFinished = TRUE;
				
				return;
			}
			else if (statusCode == 503)  //need to  query the statu of an incomplet upload and try again.
			{
				if (responseBufferForContent.memory)
					free(responseBufferForContent.memory);
				
				INT64 lLastByte = getResumableRange(curl, lFileSize, szUploadUri, _countof(szUploadUri));
				lBytesUploaded = lLastByte+1;

			}
			else  //failed , need to try the whole proces again????
			{
				//free header  slist
				if (headersForChunk)
					curl_slist_free_all(headersForChunk); 
				
				if (bConvert)  
				{
					if (responseBufferForContent.memory)
						free(responseBuffer.memory);

					bRetryNonConvertUpload = TRUE;
					bConvert=FALSE;
					break;  //retry with non-convert upload
				}
				else
				{
					char szErrMsg[512]={0};
					getErrMsgFromResponse(responseBufferForContent.memory, szErrMsg, 512);
					
					if (responseBufferForContent.memory)
						free(responseBufferForContent.memory);

					throw std::runtime_error(szErrMsg);
				}
			}
		} while (!bUploadFinished);  //do the chunck upload loop until finished

	}while(bRetryNonConvertUpload);  //if cannot convert , then retry unConvert upload



	//finial cleanup
	if (curl)
		curl_easy_cleanup(curl);

	CloseHandle(hFile);
}


	


/*****************************************************************************
Export Google Docs file to other format file
Params:
	[in] lpszContentUrl:  the url in the Entry->content->src:  like this https://docs.google.com/feeds/download/documents/Export?docId=0AbCmbVXdOi7mZGhianRiZHFfNDRmdHR0Mnp3cA
											or like this https://doc-10-1k-docs.googleusercontent.com/docs/secure/p62krtm66k35ibqhev55ra8osq858oka/5he22kkft8bpnulrh282rrj13e6mmmqc/1277532000000/16813505762710726417/16813505762710726417/0B7CmbVXdOi7mNWE0MzI3MmEtZjc5OC00MjYyLTg1ODAtMDJjMTIxNjUzNzU5?h=16653014193614665626&e=download&gd=true
	[in] lpszFileType: "document" "spreadsheet"  "presentation" "pdf" "file"  ,   this is from the gd:resourceId.  GDocsEntry::GetType();	
	[in] lpszFilePath: the Path that the exported file is being saved to. like d:\abc\xxx.jpg
	[in] hMsg:  the Handle of the Progress Dialog
	[in] lpszFormat: the format of the exported file, 
		For "pdf" and "file" type, this param should be NULL. other value is just meaningless
		For "document" , it could be doc , html, odt, pdf, png, rtf, txt, zip  OR NULL(NULL=doc )
		For "spredsheet", it could be xls, csv, pdf, ods, tsv, html  OR NULL (NULL=xls)
		For "presentation", it could be pdf, png, ppt, sef, txt  OR NULL(NULL = ppt)
		For "drawing", it could be jpeg,pdf,png,svg or NULL(NULL=jpeg)

This method can be used both to Google Docs file or Arbitrary File
******************************************************************************/
void GDocsAPI::ExportFile(LPCSTR lpszContentUrl, LPCSTR lpszFileType, LPCWSTR lpszFilePath, HWND hMsg, LPCSTR lpszFormat)
{
	assertUserLoggedIn(); 
	
	if (lpszFilePath == NULL)
		throw std::runtime_error("File name is invalid");

	CURL* curl = curl_easy_init(); 
	if (!curl)
		throw std::runtime_error("Connection failed");  	

	//#ifdef _DEBUG
	//	curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L);		
	//#endif
	curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);  //not verify certificate!

	//set Append Header 
	struct curl_slist * headers= NULL;
	headers = curl_slist_append(headers, "GData-Version:3.0");

	CHAR * szAuthToken = NULL;
	if ( strcmp(lpszFileType,"spreadsheet") == 0)  //spreadsheet need different authentication
	{
		int iAuthLen = strlen("Authorization:GoogleLogin auth=") +strlen(m_pUser->GetTokenForSpreadSheets() ) +8;
		szAuthToken = new CHAR[iAuthLen]();
		strcpy_s(szAuthToken, iAuthLen, "Authorization:GoogleLogin auth=");
		strcat_s(szAuthToken, iAuthLen, m_pUser->GetTokenForSpreadSheets());
	}
	else  //non spreadsheet type file  
	{
		int iAuthLen = strlen("Authorization:GoogleLogin auth=") +strlen(m_pUser->GetTokenForDocs()) +8;
		szAuthToken = new CHAR[iAuthLen]();
		strcpy_s(szAuthToken, iAuthLen, "Authorization:GoogleLogin auth=");
		strcat_s(szAuthToken, iAuthLen, m_pUser->GetTokenForDocs());
	}
	headers = curl_slist_append(headers, szAuthToken);
	delete [] szAuthToken;

	curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);

	//set CURLOPT_URL
	if (strcmp(lpszFileType, "pdf")==0 || strcmp(lpszFileType, "file")==0) // arbitrary file or pdf file
	{
		curl_easy_setopt(curl, CURLOPT_URL, lpszContentUrl);
	}
	else //google docs file : document,spreadsheet, presentaion type
	{
		int iDimension = strlen(lpszContentUrl) + 32;  // strlen("&exportFormat=doc") <32;
		char* lpszUrl = new char[iDimension]();
		strcpy_s(lpszUrl, iDimension, lpszContentUrl);
		strcat_s(lpszUrl, iDimension, "&exportFormat=");

		if (lpszFormat != NULL)
		{
			strcat_s(lpszUrl, iDimension,lpszFormat);
		}
		else 
		{	
			if (strcmp(lpszFileType, "document") == 0)   //document 
				strcat_s(lpszUrl, iDimension,"doc");
			else if (strcmp(lpszFileType, "presentation") == 0)   //presentation 
				strcat_s(lpszUrl, iDimension,"ppt");
			else if (strcmp(lpszFileType, "spreadsheet") == 0)   //presentation 
				strcat_s(lpszUrl, iDimension,"xls");
			else if (strcmp(lpszFileType, "drawing") == 0) //drawing
				strcat_s(lpszUrl, iDimension,"jpeg");
			else
				strcat_s(lpszUrl, iDimension,"html");   //for default, this should never happen
		}

		curl_easy_setopt(curl, CURLOPT_URL, lpszUrl);

		delete [] lpszUrl; 
	}


	//Set write callback function
	HANDLE hFile = ::CreateFile(lpszFilePath, GENERIC_READ|GENERIC_WRITE, 
							FILE_SHARE_READ,	NULL, CREATE_ALWAYS,
							FILE_ATTRIBUTE_NORMAL, NULL);  
	if (hFile == NULL)
	{
		if (curl)
			curl_easy_cleanup(curl);
		if (headers)
			curl_slist_free_all(headers);

		throw std::runtime_error("create file failed");
	}

	//set the write function
	struct TransferInfoStruct downloadInfo;
	downloadInfo.hFile = hFile;
	downloadInfo.uBytesTransferred =0;
	downloadInfo.hDlg = hMsg;
	downloadInfo.lStartTimeStamp = HelperFunctions::GetCurrentTimeStamp();
	
	curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, GDocsAPI::WriteToFileCallback);    
	curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void*)&downloadInfo);

	CURLcode res= curl_easy_perform(curl);
	if (res!= CURLE_OK)
	{
		CloseHandle(hFile);
		if (curl)
			curl_easy_cleanup(curl);
		if (headers)
			curl_slist_free_all(headers);

		throw std::runtime_error("File Downloading/Exporting Failed.");  
	}

	CloseHandle(hFile);

	//Handle errors
	LONG statusCode =0;
	curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &statusCode);

	if (curl)
		curl_easy_cleanup(curl);
	if (headers)
		curl_slist_free_all(headers);

	if (statusCode >= 400)  //error happened.  =
	{
		throw std::runtime_error("File downloading/converting failed.");
	}
}

/*******************************************************************************************
Create a subFolder 
Params:
	[in] lpszFolderName: the name of the new folder to be created. no path included
	[in] lpszParentFolderFeed:  如： https://docs.google.com/feeds/default/private/full/folder%3A@2DFGFGDF/content"
	[out] pResponseDoc: the xml entry for the newly created folder

*****************************************************************************************/
void GDocsAPI::CreateFolder(LPSTR lpszFolderName, LPCSTR lpszParentFolderFeed, TiXmlDocument* pResponseDoc)
{
	assertUserLoggedIn(); 

	if (!lpszFolderName || strlen(lpszFolderName)==0)
	{
		throw std::runtime_error("Invalid folder name.");
	}

	CURL* curl = curl_easy_init();

	struct curl_slist * headerList = prepareCurl(curl, "application/atom+xml", NULL);

	//construct url
	if (!lpszParentFolderFeed)
	{	
		curl_easy_setopt(curl, CURLOPT_URL, "https://docs.google.com/feeds/default/private/full");
	}
	else
	{
		curl_easy_setopt(curl, CURLOPT_URL, lpszParentFolderFeed);
		
		//int nDim = strlen(lpszParentId) + 128;
		//char* lpszUrl = new char[nDim]();
		//strcpy_s(lpszUrl,nDim, "https://docs.google.com/feeds/default/private/full/folder%3A");
		//strcat_s(lpszUrl, nDim, lpszParentId);
		//strcat_s(lpszUrl, nDim, "/contents");
		//
		//curl_easy_setopt(curl, CURLOPT_URL, lpszUrl);
		//delete [] lpszUrl;
	}

	//set the response write function
	struct MemoryStruct  responseBuffer;
	responseBuffer.memory = NULL;
	responseBuffer.size = 0;
	curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, GDocsAPI::responseWriteCallback);   
	curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void*)&responseBuffer);

	//construct Post Body
	int iSize = strlen(lpszFolderName)+512;
	//if there is a "&" in the lpszFoldername, convert it to "&amp;"! otherwise createfolder will fail.
	string strFolderName = lpszFolderName;
	strFolderName = HelperFunctions::StringReplace(strFolderName, "&", "&amp;" );

	char* lpszPostBody = new char[iSize]();
	strcpy_s(lpszPostBody, iSize, "<?xml version='1.0' encoding='UTF-8'?>");
	strcat_s(lpszPostBody, iSize, "<entry xmlns=\"http://www.w3.org/2005/Atom\">");
	strcat_s(lpszPostBody, iSize,  "<category scheme=\"http://schemas.google.com/g/2005#kind\" term=\"http://schemas.google.com/docs/2007#folder\"/>");
	strcat_s(lpszPostBody, iSize, "<title>");
	strcat_s(lpszPostBody, iSize, strFolderName.c_str());
	strcat_s(lpszPostBody, iSize,   "</title></entry>");

	curl_easy_setopt(curl, CURLOPT_POSTFIELDS, lpszPostBody);

	CURLcode res = curl_easy_perform(curl);
	delete [] lpszPostBody;	
	
	if (res!= CURLE_OK)
	{
		if (responseBuffer.memory)
			free(responseBuffer.memory);
		if (headerList)
			curl_slist_free_all(headerList);
		if (curl)
			curl_easy_cleanup(curl);

		throw std::runtime_error("Create Folder Failed.");
	}
	
	//Google returns either an HTTP 201 created response for successful folder creation.
	LONG statusCode =0;
	curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &statusCode);
	
	if (statusCode == 201)  //succeed!
	{
		pResponseDoc->Clear();
		pResponseDoc->Parse(responseBuffer.memory, 0, TIXML_ENCODING_UTF8);
		
		if (responseBuffer.memory)
			free(responseBuffer.memory);
		if (headerList)
			curl_slist_free_all(headerList);
		if (curl)
			curl_easy_cleanup(curl);
	}
	else	//error!
	{
		char szErrMsg[512]={0};
		getErrMsgFromResponse(responseBuffer.memory, szErrMsg, 512);

		if (responseBuffer.memory)
			free(responseBuffer.memory);
		if (headerList)
			curl_slist_free_all(headerList);
		if (curl)
			curl_easy_cleanup(curl);

		throw std::runtime_error(szErrMsg);
	}
}

/*************************************************************************************************
Move an entry( a file or a folder) into another folder
params:
	[in]lpszEntryId: the id of the entry to be moved
	[in]lpszEntryType: document, presentation, spreadsheet, pdf, file , folder
	[in]lpszDesFolderId: the id of the entry's Destination folder, "root" for root folder 
	[in]lpszSrcFolderId: the id of the entry's source parent folder, "root" for root folder

To Move an entry, TWO steps:
1. move the entry into a new destination folder
2. delete the entry in the source folder.

注意，这里不能用EditLink这种参数，因为ｂｏｄｙ中的内容必须手动来构造，需要EntryId,和EntryType
*********************************************************************************************/
void GDocsAPI::MoveEntry(LPCSTR lpszEntryId, LPCSTR lpszEntryType, LPCSTR lpszDesFolderId, LPCSTR lpszSrcFolderId)
{
	assertUserLoggedIn(); 

	if (!lpszEntryId || strlen(lpszEntryId)==0)
		throw std::runtime_error("Invalid Entry Id.");
	if (!lpszDesFolderId || strlen(lpszDesFolderId) ==0)
		throw std::runtime_error("Invalid Destination Folder Id.");
	if (!lpszSrcFolderId || strlen(lpszSrcFolderId) ==0)
		throw std::runtime_error("Invalid Source Folder Id.");

	CURL* curl = curl_easy_init();
	curl_slist * headerList = prepareCurl(curl, "application/atom+xml", NULL);

	//construct url
	int nDim = strlen(lpszDesFolderId) + 128;
	char* lpszUrl = new char[nDim]();
	strcpy_s(lpszUrl,nDim, "https://docs.google.com/feeds/default/private/full/folder%3A");
	strcat_s(lpszUrl, nDim, lpszDesFolderId);
	strcat_s(lpszUrl, nDim, "/contents");
	curl_easy_setopt(curl, CURLOPT_URL, lpszUrl);
	delete [] lpszUrl;

	//set the response write function
	struct MemoryStruct  responseBuffer;
	responseBuffer.memory = NULL;
	responseBuffer.size = 0;
	curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, GDocsAPI::responseWriteCallback);   
	curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void*)&responseBuffer);

	//construct Post Body
	int iSize = strlen(lpszEntryId)+256;
	char* lpszPostBody = new char[iSize]();
	strcpy_s(lpszPostBody, iSize, "<?xml version='1.0' encoding='UTF-8'?>");
	strcat_s(lpszPostBody, iSize, "<entry xmlns=\"http://www.w3.org/2005/Atom\">");
	strcat_s(lpszPostBody, iSize,  "<id>https://docs.google.com/feeds/default/private/full/");
	strcat_s(lpszPostBody, iSize, lpszEntryType);
	strcat_s(lpszPostBody, iSize, "%3A");
	strcat_s(lpszPostBody, iSize,   lpszEntryId);
	strcat_s(lpszPostBody, iSize,   "</id></entry>");
	curl_easy_setopt(curl, CURLOPT_POSTFIELDS, lpszPostBody);

	CURLcode res = curl_easy_perform(curl);
	delete [] lpszPostBody;

	if (res!= CURLE_OK)
	{
		if (responseBuffer.memory)
			free(responseBuffer.memory);
		if (headerList)
			curl_slist_free_all(headerList);
		if (curl)
			curl_easy_cleanup(curl);

		throw std::runtime_error("Move Operation Failed.");
	}

	LONG statusCode =0;
	curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &statusCode);
	if (statusCode >=400)  //error happens!
	{
		char szErrMsg[512] ={0};
		getErrMsgFromResponse(responseBuffer.memory, szErrMsg, 512);
		
		if (responseBuffer.memory)
			free(responseBuffer.memory);
		if (headerList)
			curl_slist_free_all(headerList);
		if (curl)
			curl_easy_cleanup(curl);

		throw std::runtime_error(szErrMsg);
	}

	if (responseBuffer.memory)
		free(responseBuffer.memory);
	responseBuffer.memory = NULL;
	responseBuffer.size =0;
	if (headerList)
		curl_slist_free_all(headerList);


	//delet the original link : move the entry out of the original folder
	//DELETE https://docs.google.com/feeds/default/private/full/folder%3Afolder_id/contents/document%3Adocument_id
	
	curl_easy_reset(curl);
	struct curl_slist * headers = prepareCurl(curl, NULL, "*");
	
	curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "DELETE");

	//constuct url
	int nSize = strlen(lpszEntryId)+strlen(lpszSrcFolderId)+256;
	char* lpszDelUrl = new char[nSize]();
	strcpy_s(lpszDelUrl, nSize, "https://docs.google.com/feeds/default/private/full/folder%3A");
	strcat_s(lpszDelUrl, nSize, lpszSrcFolderId);
	strcat_s(lpszDelUrl, nSize, "/contents/");
	strcat_s(lpszDelUrl, nSize, lpszEntryType);
	strcat_s(lpszDelUrl, nSize, "%3A");
	strcat_s(lpszDelUrl, nSize, lpszEntryId);

	curl_easy_setopt(curl, CURLOPT_URL, lpszDelUrl);
	delete[] lpszDelUrl;

	curl_easy_perform(curl);  //there is no error handling for the second step, because the first step has finished.

	if (headers)
		curl_slist_free_all(headers);

	if (curl)
		curl_easy_cleanup(curl);

}

/*****************************************************************************************
Delete /Trash a file or folder
If isDeleted is TRUE, then delete the entry completely
if isDeleted is FALSE, trash it. 
//the linkedit does not work for file in subfolders , so we use ResourceId to construct the URL
Param:
	[in] lpszResourceId: the resourceId of the entry to be renamed.  like : document:0ca3b233209090...
	[in] isDeleted:   TRUE for delete, FALSE for trash.        The default is FALSE
注意：该方法不能直接使用EditLink, 有问题，必须用拼接的方式来处理！！！
***************************************************************************/
void GDocsAPI::DeleteEntry(LPSTR lpszResourceId, BOOL isDeleted)
{
	assertUserLoggedIn();
	if (!lpszResourceId || strlen(lpszResourceId)==0)
		throw std::runtime_error("Invalid Entry Id.");
	
	CURL* curl = curl_easy_init();
	curl_slist * headerList = prepareCurl(curl, NULL, "*");

	//get  Type and Id from the ResouceId 
	char szType[128]={0};
	strcpy_s(szType, 128, lpszResourceId);
	char* szEnd = strchr(szType,':');
	if (szEnd)
		szEnd[0]=0;  //NULL terminated
	
	char* lpszEntryId = strchr(lpszResourceId, ':');
	//LPSTR lpszEntryId = NULL;
	if (lpszEntryId)
	{
		lpszEntryId ++;  
	}
	
	//construct URL
	int nDim = strlen(lpszEntryId) + 256;
	char* lpszUrl = new char[nDim]();
	strcpy_s(lpszUrl,nDim, "https://docs.google.com/feeds/default/private/full/");
	strcat_s(lpszUrl, nDim, szType);
	strcat_s(lpszUrl, nDim, "%3A");
	strcat_s(lpszUrl, nDim, lpszEntryId);

	if (isDeleted)
	{
		strcat_s(lpszUrl, nDim, "?delete=true");
	}
	curl_easy_setopt(curl, CURLOPT_URL, lpszUrl);
	delete [] lpszUrl;

	//set the response write function
	struct MemoryStruct  responseBuffer;
	responseBuffer.memory = NULL;
	responseBuffer.size = 0;
	curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, GDocsAPI::responseWriteCallback);   
	curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void*)&responseBuffer);
	
	curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "DELETE");

	CURLcode res = curl_easy_perform(curl);
	if (res!= CURLE_OK)
	{
		if (responseBuffer.memory)
			free(responseBuffer.memory);
		if (headerList)
			curl_slist_free_all(headerList);
		if (curl)
			curl_easy_cleanup(curl);

		throw std::runtime_error("Move Operation Failed.");
	}
	
	LONG statusCode =0;
	curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &statusCode);
	if (statusCode >=400)  //error happens!
	{
		char szErrMsg[512] ={0};
		getErrMsgFromResponse(responseBuffer.memory, szErrMsg, 512);
		
		if (responseBuffer.memory)
			free(responseBuffer.memory);
		if (headerList)
			curl_slist_free_all(headerList);
		if (curl)
			curl_easy_cleanup(curl);

		throw std::runtime_error(szErrMsg);
	}

	if (responseBuffer.memory)
		free(responseBuffer.memory);
	if (headerList)
		curl_slist_free_all(headerList);
	if (curl)
		curl_easy_cleanup(curl);
}

/********************************************************************************************************
Rename the Entry
Params:
	[in] lpszEntryLink: the edit link (m_pszLinkEdit) of the entry to be renamed. like: https://docs.google.com/feeds/default/private/full/document%3A19QlFP5je6Suh7OwnuoyC2Kru5id6UIGMBeaFwbdYQo0
	[in] lpszNewName: the new Name

using "Updating a document's metadata" ,  call updateMetadata() 
********************************************************************************************************/
void GDocsAPI::RenameEntry(LPCSTR lpszEditLink, LPCSTR lpszNewName)
{
	int nDim = strlen(lpszNewName)+64;

	//if there is a "&" in the lpszFoldername, convert it to "&amp;"! otherwise createfolder will fail.
	string strNewName = lpszNewName;
	strNewName = HelperFunctions::StringReplace(strNewName, "&", "&amp;");
	
	char* szTitle = new char[nDim]();
	strcpy_s(szTitle, nDim, "<title>");
	strcat_s(szTitle, nDim, strNewName.c_str());
	strcat_s(szTitle, nDim, "</title>");

	try
	{
		updateMetadata(lpszEditLink, szTitle);
	}
	catch (std::runtime_error e)
	{
		delete [] szTitle;
		throw e;
	}
	catch (...)
	{
		delete [] szTitle;
		throw std::runtime_error("Rename failed.");
	}

	delete [] szTitle;
}
	

/*************************************************************
Star / Unstar  the Entry
Params:
	[in] lpszEditLink: the  Edit link of the entry (m_pszLinkEdit)  href="https://docs.google.com/feeds/default/private/full/document%3A19QlFP5je6Suh7OwnuoyC2Kru5id6UIGMBeaFwbdYQo0"
	[in] lstarOrNot:  TRUE: star the entry         FALSE: unstar the entry

using "Updating a document's metadata" ,  call updateMetadata() 

****************************************************************/
void GDocsAPI::StarEntry(LPCSTR lpszEditLink, BOOL starOrNot)
{
	char* szStarMetadata = NULL;
	if (starOrNot)
		szStarMetadata = "<category scheme=\"http://schemas.google.com/g/2005/labels\" term=\"http://schemas.google.com/g/2005/labels#starred\" label=\"starred\"/>";
	else
		szStarMetadata = "<category scheme=\"http://schemas.google.com/g/2005/labels\" term=\"http://schemas.google.com/g/2005/labels#starred\" label=\"\"/>";
	
	try
	{	
		updateMetadata(lpszEditLink,szStarMetadata );
	}
	catch (std::runtime_error e)
	{
		throw e;
	}
	catch (...)
	{
		throw std::runtime_error("Star/UnStar failed.");
	}
}

///*************************************************************
//Hide / UnHide  the Entry
//Params:
//	[in] lpszEditLink: the  Edit href link of the entry to be renamed.   (m_pszLinkEdit)  href="https://docs.google.com/feeds/default/private/full/document%3A19QlFP5je6Suh7OwnuoyC2Kru5id6UIGMBeaFwbdYQo0"
//	[in] hideOrNot:  TRUE: hide the entry         FALSE: unhide the entry
//
//using "Updating a document's metadata" ,  call updateMetadata() 
//
//****************************************************************/
//void GDocsAPI::HideEntry(LPCSTR lpszEditLink, BOOL hideOrNot)
//{
//	char* szHideMetadata = NULL;
//	if (hideOrNot)
//		szHideMetadata = "<category scheme=\"http://schemas.google.com/g/2005/labels\" term=\"http://schemas.google.com/g/2005/labels#hidden\" label=\"hidden\"/>";
//	else
//		szHideMetadata = "<category scheme=\"http://schemas.google.com/g/2005/labels\" term=\"http://schemas.google.com/g/2005/labels#hidden\" label=\"\"/>";
//	
//	try
//	{	
//		updateMetadata(lpszEditLink,szHideMetadata );
//	}
//	catch (std::runtime_error e)
//	{
//		throw e;
//	}
//	catch (...)
//	{
//		throw std::runtime_error("Hide/Unhide failed.");
//	}
//}


/*****************************************************************************************
Retrieve the ACL (Access Control List) information of the specific entry
Params:
	[in] lpszEntryId: the id of the entry
	[in] lpszType:  file, folder, document, spreadsheet, presentation, pdf
	[out] pResonseDoc:  the returned XML response describing the ACL of the entry.  

From the pResponseDoc, we can get the owner, collaborators/writers, viewers/readers  of the entry. 

******************************************************************************************/
void GDocsAPI::GetEntryACL(LPCSTR lpszEntryId, LPCSTR lpszType, TiXmlDocument * pXmlDoc)
{
	assertUserLoggedIn(); 

	CURL* curl = curl_easy_init(); 
	if (!curl)
		throw std::runtime_error("Connection failed");  	

	curl_slist * headerList= prepareCurl(curl);

	//construct url
	int iDim = strlen(lpszEntryId)+256;
	char* lpszUrl = new char[iDim]();
	strcpy_s(lpszUrl, iDim, "https://docs.google.com/feeds/default/private/full/");
	strcat_s(lpszUrl, iDim, lpszType);
	strcat_s(lpszUrl, iDim, "%3A");
	strcat_s(lpszUrl, iDim, lpszEntryId);
	strcat_s(lpszUrl, iDim, "/acl");

	curl_easy_setopt(curl, CURLOPT_URL, lpszUrl);
	delete [] lpszUrl;

	//Set write callback function
	struct MemoryStruct  responseBuffer;
	responseBuffer.memory = NULL;
	responseBuffer.size = 0;

	curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, GDocsAPI::responseWriteCallback);    
	curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void*)&responseBuffer);

	//perform the request
	CURLcode res= curl_easy_perform(curl);
	if (res!= CURLE_OK)
	{
		if (responseBuffer.memory)
			free(responseBuffer.memory);

		if (headerList)
			curl_slist_free_all(headerList);	//free hader slist
		
		if (curl)
			curl_easy_cleanup(curl);		//free curl handle 

		throw std::runtime_error("Get ACL informaiton failed.");
	}

	LONG statusCode =0;
	curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &statusCode);

	if (statusCode <400)  //succeed
	{
		pXmlDoc->Clear();
		pXmlDoc->Parse(responseBuffer.memory, 0, TIXML_ENCODING_UTF8);  

		if (responseBuffer.memory)
			free(responseBuffer.memory);

		if (headerList)
			curl_slist_free_all(headerList);	//free hader slist
		
		if (curl)
			curl_easy_cleanup(curl);		//free curl handle 
	}
	else  //error happend
	{
		char szErrMsg[512]={0};
		getErrMsgFromResponse(responseBuffer.memory, szErrMsg, 512);

		if (responseBuffer.memory)
			free(responseBuffer.memory);

		if (headerList)
			curl_slist_free_all(headerList);	//free hader slist
		
		if (curl)
			curl_easy_cleanup(curl);		//free curl handle 
	
		throw std::runtime_error(szErrMsg);
	}		
	
}

/***************************************************************************************
Share this entry(either a file or a folder) to a User( either a specific user, a google group, or  a google apps domain， or even publish to all users)
Params:
	[in] lpszEntryId: the Id of the entry
	[in] lpszType: the Type of the entry:  file, folder, document, spreadsheet, presentation, pdf
	[in] lpszRole:  writer  or reader
	[in] lpszScope:		user:    a user
					group:	a google group , a group email address
					domain:	a google app domain (ususally for business users), 这个是否能成功要取决于 google domain的设置。
					default:	the public ( To all internet users)  ,  The document will be crawlable by search engrines, and anyone will be able to view or edit the document.
	[in] lpszUser:   for user: a user's email
				for group:  a group's email
				for domain:  the domain name, like "driveoncloud.com" 
				for default/public:  NULL, this parameter is ignored.

	目前存在的问题是： email无法设置subject和content,不知道什么时候可以。
****************************************************************************************/
void GDocsAPI::AddACLUser(LPCSTR lpszEntryId, LPCSTR lpszType, LPCSTR lpszRole, LPCSTR lpszScope, LPCSTR lpszUser/*, LPCSTR lpszSubject, LPCSTR lpszMessage*/)
{
	assertUserLoggedIn(); 

	if (!lpszEntryId || strlen(lpszEntryId)==0)
	{
		throw std::runtime_error("Invalid Entry Id.");
	}

	CURL* curl = curl_easy_init();
	struct curl_slist * headerList = prepareCurl(curl, "application/atom+xml", NULL);

	//construct url
	int iDim = strlen(lpszEntryId)+256;
	char* lpszUrl = new char[iDim]();
	strcpy_s(lpszUrl, iDim, "https://docs.google.com/feeds/default/private/full/");
	strcat_s(lpszUrl, iDim, lpszType);
	strcat_s(lpszUrl, iDim, "%3A");
	strcat_s(lpszUrl, iDim, lpszEntryId);
	strcat_s(lpszUrl, iDim, "/acl");

	curl_easy_setopt(curl, CURLOPT_URL, lpszUrl);
	delete [] lpszUrl;

	//set the response write function
	struct MemoryStruct  responseBuffer;
	responseBuffer.memory = NULL;
	responseBuffer.size = 0;
	curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, GDocsAPI::responseWriteCallback);   
	curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void*)&responseBuffer);

	//construct post body
	int iSize =0;
	if (lpszUser)
		iSize = strlen(lpszUser)+512;
	else
		iSize = 512;

	char* lpszPostBody = new char[iSize]();
	strcpy_s(lpszPostBody, iSize, "<entry xmlns=\"http://www.w3.org/2005/Atom\"  xmlns:gAcl='http://schemas.google.com/acl/2007'>");
	strcat_s(lpszPostBody, iSize,  "<category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/acl/2007#accessRule'/>");
	strcat_s(lpszPostBody, iSize, "<gAcl:role value='");
	strcat_s(lpszPostBody, iSize, lpszRole);
	strcat_s(lpszPostBody, iSize,   "'/>");
	strcat_s(lpszPostBody, iSize,   "<gAcl:scope type='");
	strcat_s(lpszPostBody, iSize,   lpszScope);
	if (strcmp(lpszScope, "default") ==0)  //public sharing
	{
		strcat_s(lpszPostBody, iSize,   "'/>");
	}
	else
	{
		strcat_s(lpszPostBody, iSize,   "'  value='");
		strcat_s(lpszPostBody, iSize,   lpszUser);
		strcat_s(lpszPostBody, iSize,   "'/>");
	}
	strcat_s(lpszPostBody, iSize,   "</entry>");

	curl_easy_setopt(curl, CURLOPT_POSTFIELDS, lpszPostBody);

	CURLcode res = curl_easy_perform(curl);
	delete [] lpszPostBody;	
	
	if (res!= CURLE_OK)
	{
		if (responseBuffer.memory)
			free(responseBuffer.memory);
		if (headerList)
			curl_slist_free_all(headerList);
		if (curl)
			curl_easy_cleanup(curl);

		throw std::runtime_error("Sharing failed.");
	}
	//Google returns either an HTTP 201 created response for successful folder creation.
	LONG statusCode =0;
	curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &statusCode);
	
	if (statusCode <400)  //succeed!
	{
		if (responseBuffer.memory)
			free(responseBuffer.memory);
		if (headerList)
			curl_slist_free_all(headerList);
		if (curl)
			curl_easy_cleanup(curl);
	}
	else	//error!
	{
		char szErrMsg[512]={0};
		getErrMsgFromResponse(responseBuffer.memory, szErrMsg, 512);

		if (responseBuffer.memory)
			free(responseBuffer.memory);
		if (headerList)
			curl_slist_free_all(headerList);
		if (curl)
			curl_easy_cleanup(curl);

		throw std::runtime_error(szErrMsg);
	}
}

/*******************************************************************************************
Update sharing persmission, use HTTP PUT, change Role to "reader" or "writer"
Params:
	[in] lpszACLEditLink: the Link-edit  of the ACL entry.  
			like: https://docs.google.com/feeds/default/private/full/file%3A0B7CmbVXdOi7mMjM1ZGEwODEtOGVhYy00MmU2LWFmZTEtOTkxM2EzMTFhYmQ4/acl/group%3Agdocsdrive%40googlegroups.com
	[in] lpszGDEtag: the gd:etag of the entry. used to identify the specific entry. like: W/"DkYNQns8eit7ImA9Wx9QFko."
	[in] lpszScopeType: the gAcl:scope-type,   the value could be one of :  "user", "group", "domain", "default".
	
	[in] lpszScopeValue: the gAcl:scopy-value.    
				for user: a user's email
				for group:  a group's email
				for domain:  the domain name, like "driveoncloud.com" 
				for default/public:  NULL, this parameter is ignored. 
	[in] lpszNewRole: "writer" or "reader"

****************************************************************************************/
void GDocsAPI::UpdateACLUser(LPCSTR lpszACLEditLink,  LPCSTR lpszGDEtag, LPCSTR lpszScopeType, LPCSTR lpszScopeValue, LPCSTR lpszNewRole)
{
	assertUserLoggedIn(); 

	if (!lpszACLEditLink || strlen(lpszACLEditLink)==0)
		throw std::runtime_error("Invalid Entry link.");
	

	CURL* curl = curl_easy_init();
	curl_slist * headerList = prepareCurl(curl, "application/atom+xml", "*");

	curl_easy_setopt(curl,CURLOPT_UPLOAD, 1L);   //use PUT method

	curl_easy_setopt(curl, CURLOPT_URL, lpszACLEditLink);


	//xml body, set read functon
	int nDim = strlen(lpszNewRole) +384;
	char* lpszBody =  new char[nDim]();
	strcpy_s(lpszBody,  nDim, "<entry xmlns=\"http://www.w3.org/2005/Atom\"  xmlns:gAcl='http://schemas.google.com/acl/2007'   xmlns:gd='http://schemas.google.com/g/2005'  gd:etag='");
	strcat_s(lpszBody,  nDim,	 lpszGDEtag);
	strcat_s(lpszBody,  nDim, "'>");
	strcat_s(lpszBody,  nDim, "<category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/acl/2007#accessRule'/>");
	strcat_s(lpszBody,  nDim, "<gAcl:role value='");
	strcat_s(lpszBody,  nDim, lpszNewRole);
	strcat_s(lpszBody,  nDim, "'/>");
	strcat_s(lpszBody,  nDim, "<gAcl:scope type='");
	strcat_s(lpszBody,  nDim, lpszScopeType);
	strcat_s(lpszBody,  nDim, "' ");
	
	if ( strcmp(lpszScopeType, "default") != 0)   //default(public)type do not have scope value!
	{
		strcat_s(lpszBody,  nDim, "  value='");
		strcat_s(lpszBody,  nDim, lpszScopeValue);
		strcat_s(lpszBody,  nDim, "'");
	}
	strcat_s(lpszBody,  nDim, "/>");

	strcat_s(lpszBody,  nDim, "</entry>");

	struct MemoryStruct readBuffer;
	readBuffer.memory = lpszBody;
	readBuffer.size = strlen(lpszBody);

	curl_easy_setopt(curl, CURLOPT_READFUNCTION, readCallback);
	curl_easy_setopt(curl, CURLOPT_READDATA, (void*)&readBuffer);

	//set the response write function
	struct MemoryStruct  responseBuffer;
	responseBuffer.memory = NULL;
	responseBuffer.size = 0;
	curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, GDocsAPI::responseWriteCallback);   
	curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void*)&responseBuffer);

	CURLcode res = curl_easy_perform(curl);
	delete [] lpszBody;

	if (res!= CURLE_OK)
	{
		if (responseBuffer.memory)
			free(responseBuffer.memory);
		if (headerList)
			curl_slist_free_all(headerList);
		if (curl)
			curl_easy_cleanup(curl);

		throw std::runtime_error(" Operation Failed, Probably due to connection problem.");
	}

	LONG statusCode =0;
	curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &statusCode);
	if (statusCode >=400)  //error happens!
	{
		char szErrMsg[512] ={0};
		getErrMsgFromResponse(responseBuffer.memory, szErrMsg, 512);
		
		if (responseBuffer.memory)
			free(responseBuffer.memory);
		if (headerList)
			curl_slist_free_all(headerList);
		if (curl)
			curl_easy_cleanup(curl);

		throw std::runtime_error(szErrMsg);
	}

	if (responseBuffer.memory)
		free(responseBuffer.memory);
	if (headerList)
		curl_slist_free_all(headerList);
	if (curl)
		curl_easy_cleanup(curl);
}

/********************************************************************************
Remove permisssions for this user, isssue a HTTP DELETE request to the same edit link that 
Params:
	[in] lpszACLEditLink: the Link-edit  of the ACL entry.  
			like: https://docs.google.com/feeds/default/private/full/file%3A0B7CmbVXdOi7mMjM1ZGEwODEtOGVhYy00MmU2LWFmZTEtOTkxM2EzMTFhYmQ4/acl/group%3Agdocsdrive%40googlegroups.com

******************************************************************************/
void GDocsAPI::DeleteACLUser(LPCSTR lpszACLEditLink)
{
	assertUserLoggedIn();

	if (!lpszACLEditLink || strlen(lpszACLEditLink)==0)
		throw std::runtime_error("Invalid ACL Entry Link.");


	CURL* curl = curl_easy_init();
	curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "DELETE");
	curl_slist * headerList = prepareCurl(curl, "application/atom+xml", NULL);


	curl_easy_setopt(curl, CURLOPT_URL, lpszACLEditLink);
	

	//set the response write function
	struct MemoryStruct  responseBuffer;
	responseBuffer.memory = NULL;
	responseBuffer.size = 0;
	curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, GDocsAPI::responseWriteCallback);   
	curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void*)&responseBuffer);

	CURLcode res = curl_easy_perform(curl);

	if (res!= CURLE_OK)
	{
		if (responseBuffer.memory)
			free(responseBuffer.memory);
		if (headerList)
			curl_slist_free_all(headerList);
		if (curl)
			curl_easy_cleanup(curl);

		throw std::runtime_error("Delete sharing permission failed.");
	}

	LONG statusCode =0;
	curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &statusCode);
	if (statusCode >=400)  //error happens!
	{
		char szErrMsg[512] ={0};
		getErrMsgFromResponse(responseBuffer.memory, szErrMsg, 512);
		
		if (responseBuffer.memory)
			free(responseBuffer.memory);
		if (headerList)
			curl_slist_free_all(headerList);
		if (curl)
			curl_easy_cleanup(curl);

		throw std::runtime_error(szErrMsg);
	}

	if (responseBuffer.memory)
		free(responseBuffer.memory);
	responseBuffer.memory = NULL;
	responseBuffer.size =0;
	if (headerList)
		curl_slist_free_all(headerList);
}

